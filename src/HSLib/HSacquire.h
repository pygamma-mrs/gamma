/* HSacquire.h **************************************************-*-c++-*-
**									**
**	 	                G A M M A				**
**									**
**	Hilbert Space Library Acquisitions              Implementation	**
**									**
**	Copyright (c) 1990, 1991, 1992				 	**
**	Zoltan Madi, Scott Smith				 	**
**	Eidgenoessische Technische Hochschule	 			**
**	Labor fuer physikalische Chemie			 		**
**	8092 Zurich / Switzerland		 			**
**									**
**      $Header: $
**									**
*************************************************************************/

/*************************************************************************
**								 	**
** Description							 	**
**								 	**
** The GAMMA Platform Provides Functions for Simulation	of Magnetic	**
** Resonance Experiments and Other Associated athematical		**
** Capabilities. The Set of Functions Herein Allow for the Simulation	**
** of Free Induction Decays(FID's) in Spin Hilbert Space & Adds 	**
** Abilities Related To Simulated Data Acquistion.			**
**								 	**
*************************************************************************/


#ifndef   HSacquire_h_			// Is file already included?
#  define HSacquire_h_ 1		// If no, then remember it
#  if defined(GAMPRAGMA)		// Using the GNU compiler
#    pragma interface			// This is the interface
#  endif

#include <GamGen.h>			// Know MSVCDLL (__declspec)
#include <Matrix/row_vector.h>		// Include row vectors
#include <HSLib/GenOp.h>		// Include operators
#include <HSLib/HSprop.h>		// Include Hilbert space propagators
 
// ____________________________________________________________________________
// A                     Generic Free Induction Decays
// ____________________________________________________________________________
 
/* At acquisition point k, which corresponds to time t = k*td, we have
   when working in the eigenbasis of the propagator U = exp(-2*pi*i*H*td)
 
   fid(k) = Trace { D * sigma(t) }
 
                         k                        k
          = Trace { D * U (td)  * sig0 * adjoint[U (td) }
 
                                 k                            k  
          = Sum i,j { <i|D|j><j|U (td)|j>*<j|sig0|i>*conj(<i|U (td)|i>) }
 
                                                                 k
          = Sum i,j { <i|D|j><j|sig0|i> * [<j|U|j>*conj(<i|U|i>)]  }
 
                                     k                        k  
          = Sum i,j { A(i,j) * B(i,j) }    =  Sum p { A(p) * B (p) }
 
   The FID functions all implement the last form for generating a series
   of expectation values evenly incremented in time.  The routines will
   immediately generate the arrays A and B then quicky do the sum. The
   points are repeatly generated by taking powers of B elements.

	   Input		sig0 : Operator propagated (initial dens. mx)
	   			D    : Detection operator in trace computation
	  	 		H    : Hamiltonian for propagation (in Hertz)
			        U    : Propagator for one increment
	  	 		td   : Evolution time (seconds, per point)
	  	 		N    : Number of points to generate
	  			fid  : Data vector containing the result
	   Output		     : none, fid data vector filled
	   Note			     : If no block size is specified it will
				       be taken as the vector size
	   Note			     : If no vector is specified on will be
				       generated and returned                */  

//          Functions Which Take A row_vector As An Argument
//                           (acquire == FID)

MSVCDLL void acquire(gen_op& sig0,gen_op& D,gen_op& H,double td,int N,row_vector& fid, double CO=1.e-18);
MSVCDLL void acquire(gen_op& sig0,gen_op& D,gen_op& U,          int N,row_vector& fid, double CO=1.e-18);
MSVCDLL void acquire(gen_op& sig0,gen_op& D,HSprop& U,          int N,row_vector& fid, double CO=1.e-18);

MSVCDLL void FID(gen_op&     sig0,gen_op& D,gen_op& H,double td,int N,row_vector& fid, double CO=1.e-18);
MSVCDLL void FID(gen_op&     sig0,gen_op& D,gen_op& U,          int N,row_vector& fid, double CO=1.e-18);
MSVCDLL void FID(gen_op&     sig0,gen_op& D,HSprop& U,          int N,row_vector& fid, double CO=1.e-18);

//                  Functions Which Return A row_vector 
//                           (acquire == FID)

MSVCDLL row_vector acquire(gen_op& sig0, gen_op& D, gen_op& H, double td, int N, double CO=1.e-18);
MSVCDLL row_vector acquire(gen_op& sig0, gen_op& D, gen_op& U,            int N, double CO=1.e-18);
MSVCDLL row_vector acquire(gen_op& sig0, gen_op& D, HSprop& U,            int N, double CO=1.e-18);

MSVCDLL row_vector FID(gen_op&     sig0, gen_op& D, gen_op& H, double td, int N, double CO=1.e-18);
MSVCDLL row_vector FID(gen_op&     sig0, gen_op& D, gen_op& U,            int N, double CO=1.e-18);
MSVCDLL row_vector FID(gen_op&     sig0, gen_op& D, HSprop& U,            int N, double CO=1.e-18);

 
#endif 						// HSacquire.h




